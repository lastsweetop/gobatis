package generate

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"gobatis/sqlparser"
	"golang.org/x/tools/go/packages"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"strings"
)

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	Buf bytes.Buffer // Accumulated output.
	Pkg *Package     // Package we are scanning.

	TrimPrefix  string
	LineComment bool
}

// Value represents a declared constant.
type Mapper struct {
	Name string
	Func []Func
}

type Func struct {
	Name    string
	Results []Result
	Param   Param
	Tag     string
	Sql     *sqlparser.SqlSynx
}
type Param struct {
	Name string
}

type Result struct {
	Name    string
	IsArray bool
}

// File holds a single parsed file and associated data.
type File struct {
	imp  []string
	pkg  *Package  // Package to which this file belongs.
	file *ast.File // Parsed AST.
	// These fields are reset for each type being generated.
	typeName string   // Name of the constant type.
	mappers  []Mapper // Accumulator for constant values of that type.

	trimPrefix  string
	lineComment bool
}

type Package struct {
	Name  string
	defs  map[*ast.Ident]types.Object
	files []*File
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.Buf, format, args...)
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) Format() []byte {
	src, err := format.Source(g.Buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.Buf.Bytes()
	}
	return src
}

// parsePackage analyzes the single package constructed from the patterns and tags.
// parsePackage exits if there is an error.
func (g *Generator) ParsePackage(patterns []string, tags []string) {
	cfg := &packages.Config{
		Mode: packages.LoadSyntax,
		// TODO: Need to think about constants in test files. Maybe write type_string_test.go
		// in a separate pass? For later.
		Tests:      false,
		BuildFlags: []string{fmt.Sprintf("-tags=%s", strings.Join(tags, " "))},
	}
	pkgs, err := packages.Load(cfg, patterns...)
	if err != nil {
		log.Fatal(err)
	}
	if len(pkgs) != 1 {
		log.Fatalf("error: %d packages found", len(pkgs))
	}
	g.AddPackage(pkgs[0])
}

// addPackage adds a type checked Package and its syntax files to the generator.
func (g *Generator) AddPackage(pkg *packages.Package) {
	g.Pkg = &Package{
		Name:  pkg.Name,
		defs:  pkg.TypesInfo.Defs,
		files: make([]*File, len(pkg.Syntax)),
	}

	for i, file := range pkg.Syntax {
		g.Pkg.files[i] = &File{
			file:        file,
			imp:         make([]string, 0),
			pkg:         g.Pkg,
			trimPrefix:  g.TrimPrefix,
			lineComment: g.LineComment,
		}
	}
}

func (g *Generator) Generate(typeName string) {
	g.Buf.Reset()
	g.Printf("// Code generated by \"gobatis %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
	g.Printf("package %s", g.Pkg.Name)
	g.Printf("\n\n")

	mappers := make([]Mapper, 0, 100)
	for _, file := range g.Pkg.files {
		file.typeName = typeName
		file.mappers = nil
		if file.file != nil {
			ast.Inspect(file.file, file.genDecl)
			fset := token.NewFileSet()
			ast.Print(fset, file.file)
			mappers = append(mappers, file.mappers...)

			for _, im := range file.imp {
				g.Printf("import %s\n", im)
			}
		}
	}

	for _, m := range mappers {
		g.Printf("\n")
		g.Printf("type %s struct {\n", m.Name)
		g.Printf("}\n\n")

		for _, f := range m.Func {
			g.Printf("func (this *%s) %s(", m.Name, f.Name)
			log.Println(f.Param)
			if f.Param.Name != "" {
				g.Printf("param *%s", f.Param.Name)
			}
			g.Printf(")")
			if len(f.Results) == 1 {
				if f.Results[0].IsArray {
					g.Printf("[]")
				} else {
					g.Printf("*")
				}
				g.Printf(f.Results[0].Name)
			}
			g.Printf("{\n")
			g.Printf(`rows, err := db.Query("%s"`, f.Tag)

			if f.Param.Name != "" {
				for _, p := range f.Sql.Params {
					g.Printf(",param.%s", p)
				}
			}
			g.Printf(")\n")
			g.Printf(`defer rows.Close()`)
			g.Printf("\n")

			if f.Results[0].IsArray {
				g.Printf(`results:=make([]%s,0)`, f.Results[0].Name)
			}

			g.Printf("\n")
			g.Printf(`if err != nil {
								log.Println(err.Error())
								return results
								}
								`)
			if f.Results[0].IsArray {
				g.Printf("for ")
			} else {
				g.Printf("if ")
			}
			g.Printf(`rows.Next() {
								temp:=%s{}
								`, f.Results[0].Name)
			g.Printf("rows.Scan(")

			for i, s := range f.Sql.Fields {
				g.Printf("&temp.%s", s)
				if i != len(f.Sql.Fields)-1 {
					g.Printf(",")
				}

			}

			g.Printf(")")
			g.Printf("\n")
			if f.Results[0].IsArray {
				g.Printf(`results = append(results, temp)`)
			} else {
				g.Printf("return &temp")
			}
			g.Printf("\n}\n")
			if f.Results[0].IsArray {
				g.Printf("return results")
			} else {
				g.Printf("return nil")
			}
			g.Printf("}")
			g.Printf("\n\n")
		}

	}

	src := g.Format()
	dir := filepath.Dir(".")
	baseName := fmt.Sprintf("%s_dao.go", typeName)
	outputName := filepath.Join(dir, strings.ToLower(baseName))
	err := ioutil.WriteFile(outputName, src, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

// genDecl processes one declaration clause.
func (f *File) genDecl(node ast.Node) bool {
	decl, ok := node.(*ast.GenDecl)
	if ok && decl.Tok == token.IMPORT {
		for _, spec := range decl.Specs {
			ispec := spec.(*ast.ImportSpec)
			f.imp = append(f.imp, ispec.Path.Value)
		}
		return false
	}

	if ok && decl.Tok == token.TYPE {
		for _, spec := range decl.Specs {
			tspec := spec.(*ast.TypeSpec)
			if strings.Index(tspec.Name.Name, "Mapper") == len(tspec.Name.Name)-6 {
				continue
			}

			v := Mapper{
				Name: tspec.Name.Name + "Mapper",
				Func: make([]Func, 0),
			}
			var param Param
			sspec := tspec.Type.(*ast.StructType)
			for _, field := range sspec.Fields.List {
				ft := field.Type.(*ast.FuncType)

				for _, p := range ft.Params.List {
					s, isStar := p.Type.(*ast.StarExpr)
					if isStar {
						x := s.X.(*ast.SelectorExpr)
						param = Param{
							Name: x.X.(*ast.Ident).Name + "." + x.Sel.Name,
						}
					}
				}

				result := make([]Result, 0)
				for _, r := range ft.Results.List {
					a, isArray := r.Type.(*ast.ArrayType)
					s, isStar := r.Type.(*ast.StarExpr)
					if isArray {
						elt := a.Elt.(*ast.SelectorExpr)
						result = append(result, Result{
							Name:    elt.X.(*ast.Ident).Name + "." + elt.Sel.Name,
							IsArray: true,
						})
					}
					if isStar {
						x := s.X.(*ast.SelectorExpr)
						result = append(result, Result{
							Name:    x.X.(*ast.Ident).Name + "." + x.Sel.Name,
							IsArray: false,
						})
					}
				}
				tag := reflect.StructTag(field.Tag.Value[1 : len(field.Tag.Value)-1])
				sql := sqlparser.Parser(tag.Get("batis")[1 : len(tag.Get("batis"))-1])

				v.Func = append(v.Func, Func{
					Name:    field.Names[0].Name,
					Results: result,
					Tag:     tag.Get("batis"),
					Sql:     sql,
					Param:   param,
				})
			}

			f.mappers = append(f.mappers, v)
			log.Println(spec)
		}
		return false
	}
	return true
}
